<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  <head>
    <title>testtools.content : API documentation</title>

    <meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
    <link href="bootstrap.min.css" type="text/css" rel="stylesheet" />
    <link href="apidocs.css" type="text/css" rel="stylesheet" />
  </head>
  <body>

    <nav class="navbar navbar-default">
      <div class="container">
        <div class="navbar-header">
          <a href="index.html" class="navbar-brand">
            <a href="https://github.com/testing-cabal/testtools">testtools</a> API Documentation
          </a>
        </div>
      </div>
    </nav>

    <div class="container">

      <div class="page-header">
        <h1 class="module"><code>testtools.content</code> <small>module documentation</small></h1>

        <span id="partOf">
          Part of <code><a href="testtools.html" class="code">testtools</a></code>
          
          
        </span>
      </div>

      <div class="extrasDocstring">
        
      </div>

      <div class="moduleDocstring">
        <div>Content - a MIME-like Content object.<table class="fieldTable"></table></div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id140">
  
  <tr class="class">
    
    <td>Class</td>
    <td><a href="testtools.content.Content.html" class="code">Content</a></td>
    <td><span>A MIME-like Content object.</span></td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><a href="testtools.content.StackLinesContent.html" class="code">StackLinesContent</a></td>
    <td><span>Content object for stack lines.</span></td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><a href="testtools.content.TracebackContent.html" class="code">TracebackContent</a></td>
    <td><span>Content object for tracebacks.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="testtools.content.html#StacktraceContent" class="code">StacktraceContent</a></td>
    <td><span>Content object for stack traces.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="testtools.content.html#json_content" class="code">json_content</a></td>
    <td><span>Create a JSON Content object from JSON-encodeable data.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="testtools.content.html#text_content" class="code">text_content</a></td>
    <td><span>Create a Content object from some text.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="testtools.content.html#maybe_wrap" class="code">maybe_wrap</a></td>
    <td><span>Merge metadata for func into wrapper if functools is present.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="testtools.content.html#content_from_file" class="code">content_from_file</a></td>
    <td><span>Create a Content object from a file on disk.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="testtools.content.html#content_from_stream" class="code">content_from_stream</a></td>
    <td><span>Create a Content object from a file-like stream.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="testtools.content.html#content_from_reader" class="code">content_from_reader</a></td>
    <td><span>Create a Content object that will obtain the content from reader.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="testtools.content.html#attach_file" class="code">attach_file</a></td>
    <td><span>Attach a file to this test as a detail.</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><a href="testtools.content.html#_iter_chunks" class="code">_iter_chunks</a></td>
    <td><span>Read 'stream' in chunks of 'chunk_size'.</span></td>
  </tr>
</table>
        

          
      </div>

      <div id="childList">

        <div class="function">
  <a name="testtools.content._iter_chunks">
    
  </a>
  <a name="_iter_chunks">
    
  </a>
  <div class="functionHeader">
    
    def
    _iter_chunks(stream, chunk_size, seek_offset=None, seek_whence=0):
    
  </div>
  <div class="docstring functionBody">
    
    <div>Read 'stream' in chunks of 'chunk_size'.<table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">stream</td><td>A file-like object to read from.</td></tr><tr><td></td><td class="fieldArg">chunk_size</td><td>The size of each read from 'stream'.</td></tr><tr><td></td><td class="fieldArg">seek_offset</td><td>If non-None, seek before iterating.</td></tr><tr><td></td><td class="fieldArg">seek_whence</td><td>Pass through to the seek call, if seeking.</td></tr></table></div>
  </div>
</div><div class="function">
  <a name="testtools.content.StacktraceContent">
    
  </a>
  <a name="StacktraceContent">
    
  </a>
  <div class="functionHeader">
    
    def
    StacktraceContent(prefix_content='', postfix_content=''):
    
  </div>
  <div class="docstring functionBody">
    
    <div><p>Content object for stack traces.</p>
<p>This function will create and return a 'Content' object that contains a
stack trace.</p>
<p>The mime type is set to 'text/x-traceback;language=python', so other
languages can format their stack traces differently.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">prefix_content</td><td>A unicode string to add before the stack lines.</td></tr><tr><td></td><td class="fieldArg">postfix_content</td><td>A unicode string to add after the stack lines.</td></tr></table></div>
  </div>
</div><div class="function">
  <a name="testtools.content.json_content">
    
  </a>
  <a name="json_content">
    
  </a>
  <div class="functionHeader">
    
    def
    json_content(json_data):
    
  </div>
  <div class="docstring functionBody">
    
    <div>Create a JSON Content object from JSON-encodeable data.<table class="fieldTable"></table></div>
  </div>
</div><div class="function">
  <a name="testtools.content.text_content">
    
  </a>
  <a name="text_content">
    
  </a>
  <div class="functionHeader">
    
    def
    text_content(text):
    
  </div>
  <div class="docstring functionBody">
    
    <div><p>Create a Content object from some text.</p>
<p>This is useful for adding details which are short strings.</p><table class="fieldTable"></table></div>
  </div>
</div><div class="function">
  <a name="testtools.content.maybe_wrap">
    
  </a>
  <a name="maybe_wrap">
    
  </a>
  <div class="functionHeader">
    
    def
    maybe_wrap(wrapper, func):
    
  </div>
  <div class="docstring functionBody">
    
    <div>Merge metadata for func into wrapper if functools is present.<table class="fieldTable"></table></div>
  </div>
</div><div class="function">
  <a name="testtools.content.content_from_file">
    
  </a>
  <a name="content_from_file">
    
  </a>
  <div class="functionHeader">
    
    def
    content_from_file(path, content_type=None, chunk_size=DEFAULT_CHUNK_SIZE, buffer_now=False, seek_offset=None, seek_whence=0):
    
  </div>
  <div class="docstring functionBody">
    
    <div><p>Create a Content object from a file on disk.</p>
<p>Note that unless <tt class="rst-docutils literal">buffer_now</tt> is explicitly passed in as True, the file
will only be read from when <tt class="rst-docutils literal">iter_bytes</tt> is called.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">path</td><td>The path to the file to be used as content.</td></tr><tr><td></td><td class="fieldArg">content_type</td><td>The type of content.  If not specified, defaults
to UTF8-encoded text/plain.</td></tr><tr><td></td><td class="fieldArg">chunk_size</td><td>The size of chunks to read from the file.
Defaults to <tt class="rst-docutils literal">DEFAULT_CHUNK_SIZE</tt>.</td></tr><tr><td></td><td class="fieldArg">buffer_now</td><td>If True, read the file from disk now and keep it in
memory. Otherwise, only read when the content is serialized.</td></tr><tr><td></td><td class="fieldArg">seek_offset</td><td>If non-None, seek within the stream before reading it.</td></tr><tr><td></td><td class="fieldArg">seek_whence</td><td>If supplied, pass to <tt class="rst-docutils literal">stream.seek()</tt> when seeking.</td></tr></table></div>
  </div>
</div><div class="function">
  <a name="testtools.content.content_from_stream">
    
  </a>
  <a name="content_from_stream">
    
  </a>
  <div class="functionHeader">
    
    def
    content_from_stream(stream, content_type=None, chunk_size=DEFAULT_CHUNK_SIZE, buffer_now=False, seek_offset=None, seek_whence=0):
    
  </div>
  <div class="docstring functionBody">
    
    <div><p>Create a Content object from a file-like stream.</p>
<p>Note that unless <tt class="rst-docutils literal">buffer_now</tt> is explicitly passed in as True, the stream
will only be read from when <tt class="rst-docutils literal">iter_bytes</tt> is called.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">stream</td><td>A file-like object to read the content from. The stream
is not closed by this function or the 'Content' object it returns.</td></tr><tr><td></td><td class="fieldArg">content_type</td><td>The type of content. If not specified, defaults
to UTF8-encoded text/plain.</td></tr><tr><td></td><td class="fieldArg">chunk_size</td><td>The size of chunks to read from the file.
Defaults to <tt class="rst-docutils literal">DEFAULT_CHUNK_SIZE</tt>.</td></tr><tr><td></td><td class="fieldArg">buffer_now</td><td>If True, reads from the stream right now. Otherwise,
only reads when the content is serialized. Defaults to False.</td></tr><tr><td></td><td class="fieldArg">seek_offset</td><td>If non-None, seek within the stream before reading it.</td></tr><tr><td></td><td class="fieldArg">seek_whence</td><td>If supplied, pass to <tt class="rst-docutils literal">stream.seek()</tt> when seeking.</td></tr></table></div>
  </div>
</div><div class="function">
  <a name="testtools.content.content_from_reader">
    
  </a>
  <a name="content_from_reader">
    
  </a>
  <div class="functionHeader">
    
    def
    content_from_reader(reader, content_type, buffer_now):
    
  </div>
  <div class="docstring functionBody">
    
    <div>Create a Content object that will obtain the content from reader.<table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">reader</td><td>A callback to read the content. Should return an iterable of
bytestrings.</td></tr><tr><td></td><td class="fieldArg">content_type</td><td>The content type to create.</td></tr><tr><td></td><td class="fieldArg">buffer_now</td><td>If True the reader is evaluated immediately and
buffered.</td></tr></table></div>
  </div>
</div><div class="function">
  <a name="testtools.content.attach_file">
    
  </a>
  <a name="attach_file">
    
  </a>
  <div class="functionHeader">
    
    def
    attach_file(detailed, path, name=None, content_type=None, chunk_size=DEFAULT_CHUNK_SIZE, buffer_now=True):
    
  </div>
  <div class="docstring functionBody">
    
    <div><p>Attach a file to this test as a detail.</p>
<p>This is a convenience method wrapping around <tt class="rst-docutils literal">addDetail</tt>.</p>
<p>Note that by default the contents of the file will be read immediately. If
<tt class="rst-docutils literal">buffer_now</tt> is False, then the file <em>must</em> exist when the test result is
called with the results of this test, after the test has been torn down.</p><table class="fieldTable"><tr class="fieldStart"><td class="fieldName">Parameters</td><td class="fieldArg">detailed</td><td>An object with details</td></tr><tr><td></td><td class="fieldArg">path</td><td>The path to the file to attach.</td></tr><tr><td></td><td class="fieldArg">name</td><td>The name to give to the detail for the attached file.</td></tr><tr><td></td><td class="fieldArg">content_type</td><td>The content type of the file.  If not provided,
defaults to UTF8-encoded text/plain.</td></tr><tr><td></td><td class="fieldArg">chunk_size</td><td>The size of chunks to read from the file.  Defaults
to something sensible.</td></tr><tr><td></td><td class="fieldArg">buffer_now</td><td><p>If False the file content is read when the content
object is evaluated rather than when attach_file is called.
Note that this may be after any cleanups that obj_with_details has, so
if the file is a temporary file disabling buffer_now may cause the file
to be read after it is deleted. To handle those cases, using
attach_file as a cleanup is recommended because it guarantees a
sequence for when the attach_file call is made:</p>
<pre class="rst-literal-block">
detailed.addCleanup(attach_file, 'foo.txt', detailed)
</pre></td></tr></table></div>
  </div>
</div>

      </div>
      <address>
        <a href="index.html">API Documentation</a> for <a href="https://github.com/testing-cabal/testtools">testtools</a>, generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a> at 2015-07-01 16:11:28.
      </address>

    </div>
  </body>
</html>